package yuriy.weiss.training.korova;

import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static yuriy.weiss.training.korova.Constants.DISPLAY_EACH_RESULT;
import static yuriy.weiss.training.korova.ResultManipulation.*;

/**
 * All data storage (result and intermediate) is allocated before start.<br>
 * New combinations are generated by array elements manipulation, not allocating new structures.
 */
@Slf4j
public class KorovaTravaMolokoVer4 {

    private static final int MAX_DIGITS = 10;

    public static void main( String[] args ) {
        KorovaTravaMolokoVer4 builder = new KorovaTravaMolokoVer4();
        builder.runBuild();
    }

    private final int[][] parent = new int[MAX_DIGITS][MAX_DIGITS];
    private final List<Map<String, Integer>> successCombinations = new ArrayList<>();

    private KorovaTravaMolokoVer4() {
        for ( int i = 0; i < MAX_DIGITS; i++ ) {
            parent[0][i] = i;
        }
    }

    private void runBuild() {
        log.info( "START" );
        long startTime = System.currentTimeMillis();
        buildChildren( 0 );
        long timeElapsed = System.currentTimeMillis() - startTime;
        log.info( "ELAPSED: {}", timeElapsed );
        log.info( "FINISH" );
        log.info( "SUCCESS COMBINATIONS" );
        successCombinations.forEach( combination -> {
            ResultNumbers resultNumbers = buildNumbers( combination );
            displayResult( combination, resultNumbers, true );
        } );
    }

    private void buildChildren( int level ) {
        if ( level == MAX_DIGITS - 2 ) {
            // final step
            System.arraycopy( parent[level], 0, parent[level + 1], 0, MAX_DIGITS );
            log.trace( "child1: {}", parent[level + 1] );
            checkAndDisplayResult( parent[level + 1] );
            parent[level + 1][MAX_DIGITS - 2] = parent[level][MAX_DIGITS - 1];
            parent[level + 1][MAX_DIGITS - 1] = parent[level][MAX_DIGITS - 2];
            log.trace( "child2: {}", parent[level + 1] );
            checkAndDisplayResult( parent[level + 1] );
        } else {
            System.arraycopy( parent[level], 0, parent[level + 1], 0, MAX_DIGITS );
            for ( int i = level; i < MAX_DIGITS; i++ ) {
                parent[level + 1][level] = parent[level][i];
                for ( int j = level; j < MAX_DIGITS; j++ ) {
                    if ( j < i ) {
                        parent[level + 1][j + 1] = parent[level][j];
                    } else if ( j > i ) {
                        parent[level + 1][j] = parent[level][j];
                    }
                }
                buildChildren( level + 1 );
            }
        }
    }

    private void checkAndDisplayResult( int[] result ) {
        ResultNumbers resultNumbers = buildNumbersOptimized( result );
        if ( DISPLAY_EACH_RESULT ) {
            displayResult( result, resultNumbers, false );
        }
        if ( checkResult( resultNumbers ) ) {
            successCombinations.add( buildCombination( result ) );
        }
    }
}
